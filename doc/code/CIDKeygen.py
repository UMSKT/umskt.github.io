
# This file was *autogenerated* from the file ConfirmationID.sage
from sage.all_cmdline import *   # import sage library

_sage_const_226512747484292777129613772224570045177275742 = Integer(226512747484292777129613772224570045177275742); _sage_const_19 = Integer(19); _sage_const_1370060126031496139086139099049447 = Integer(1370060126031496139086139099049447); _sage_const_2 = Integer(2); _sage_const_4 = Integer(4); _sage_const_8 = Integer(8); _sage_const_17 = Integer(17); _sage_const_1 = Integer(1); _sage_const_10 = Integer(10); _sage_const_27 = Integer(27); _sage_const_25 = Integer(25); _sage_const_52 = Integer(52); _sage_const_7 = Integer(7); _sage_const_55 = Integer(55); _sage_const_5 = Integer(5); _sage_const_41 = Integer(41); _sage_const_58 = Integer(58); _sage_const_64 = Integer(64); _sage_const_0x16A6B036D7F2A79 = Integer(0x16A6B036D7F2A79); _sage_const_0x1400606322B3B04 = Integer(0x1400606322B3B04); _sage_const_3 = Integer(3); _sage_const_0x44197B83892AD0 = Integer(0x44197B83892AD0); _sage_const_0x21840136C85381 = Integer(0x21840136C85381); _sage_const_0 = Integer(0); _sage_const_43 = Integer(43); _sage_const_0x10001 = Integer(0x10001); _sage_const_14 = Integer(14); _sage_const_6 = Integer(6); _sage_const_0x80 = Integer(0x80)
import hashlib

# 226512-274743-842923-777124-961370-722240-570042-517722-757426
installationId = _sage_const_226512747484292777129613772224570045177275742 
installationIdSize = _sage_const_19  # 17 for XP Gold, 19 for SP1+ (includes 12 bits of sha1(product key))
# all three of following are valid generated
# 013705-060122-603141-961392-086136-909901-494476
confirmationId = _sage_const_1370060126031496139086139099049447 
# 022032-220754-159721-909624-985141-504586-914001
#confirmationId = 02203220751597290962985145045891400
# 137616-847280-708585-827476-874935-313366-790880
#confirmationId = 13761847287085882747874933133679088

def decrypt(encrypted, key):
    size_half = len(encrypted) // _sage_const_2 
    size_half_dwords = size_half - (size_half % _sage_const_4 )
    last = encrypted[size_half*_sage_const_2 :]
    encrypted = encrypted[:size_half*_sage_const_2 ]
    for i in range(_sage_const_4 ):
        first = encrypted[:size_half]
        second = encrypted[size_half:]
        sha1_result = hashlib.sha1(first + key).digest()
        sha1_result = (sha1_result[:size_half_dwords] +
                       sha1_result[size_half_dwords+_sage_const_4 -(size_half%_sage_const_4 ) : size_half+_sage_const_4 -(size_half%_sage_const_4 )])
        encrypted = bytes(x ^ y for x, y in zip(second, sha1_result)) + first
    return encrypted + last

# unpack&decrypt installationId
iid = int(installationId).to_bytes(installationIdSize, byteorder='little')
iid = decrypt(iid, b'\x6A\xC8\x5E\xD4')
hwid = iid[:_sage_const_8 ]
productid = int.from_bytes(iid[_sage_const_8 :_sage_const_17 ], byteorder='little')
productkeyhash = iid[_sage_const_17 :]
pid1 = productid & ((_sage_const_1  << _sage_const_17 ) - _sage_const_1 )
pid2 = (productid >> _sage_const_17 ) & ((_sage_const_1  << _sage_const_10 ) - _sage_const_1 )
pid3 = (productid >> _sage_const_27 ) & ((_sage_const_1  << _sage_const_25 ) - _sage_const_1 )
version = (productid >> _sage_const_52 ) & _sage_const_7 
pid4 = productid >> _sage_const_55 

assert version == (_sage_const_4  if len(iid) == _sage_const_17  else _sage_const_5 )

key = hwid + int((pid1 << _sage_const_41  | pid2 << _sage_const_58  | pid3 << _sage_const_17  | pid4) & ((_sage_const_1  << _sage_const_64 ) - _sage_const_1 )).to_bytes(_sage_const_8 , byteorder='little')
# productkeyhash is not used for validation, it exists just to allow the activation server to reject keygenned pids

# now the math

p = _sage_const_0x16A6B036D7F2A79 
Fp = GF(p)
Fpx = Fp
E = HyperellipticCurve(x**_sage_const_5  + _sage_const_0x1400606322B3B04  * x**_sage_const_4  + _sage_const_0x1400606322B3B04  * x**_sage_const_3  + _sage_const_0x44197B83892AD0  * x**_sage_const_2  + _sage_const_0x21840136C85381  * x)
J = E.jacobian()

# deserialize divisor
x1 = confirmationId // (p + _sage_const_1 )
x2 = confirmationId % (p + _sage_const_1 )
if x1 <= p:
    # two or fewer points over GF(p)
    point1 = E.lift_x(Fp(-x1)) if x1 != p else None
    point2 = E.lift_x(Fp(-x2)) if x2 != p else None
    if point1 is not None and point2 is not None:
        # there are 4 variants of how lift_x() could select both y-s
        # we don't distinguish D and -D, but this still leaves 2 variants
        # the chosen one is encoded by order of x1 <=> x2
        lastbit1 = point1[_sage_const_1 ].lift() & _sage_const_1 
        lastbit2 = point2[_sage_const_1 ].lift() & _sage_const_1 
        if x2 < x1:
            if lastbit1 == lastbit2:
                point2 = E(point2[_sage_const_0 ], -point2[_sage_const_1 ])
        else:
            if lastbit1 != lastbit2:
                point2 = E(point2[_sage_const_0 ], -point2[_sage_const_1 ])
    point1 = J(point1) if point1 is not None else J(_sage_const_0 )
    point2 = J(point2) if point2 is not None else J(_sage_const_0 )
    divisor = point1 + point2
else:
    # a pair of conjugate points over GF(p^2)
    f = (x+x2)*(x+x2)-_sage_const_43 *x1*x1 # 43 is the minimal quadratic non-residue in Fp
    Fp2 = GF(p**_sage_const_2 )
    point1 = E.lift_x(f.roots(Fp2)[_sage_const_0 ][_sage_const_0 ])
    point2 = E(Fp2)(point1[_sage_const_0 ].conjugate(), point1[_sage_const_1 ].conjugate())
    divisor = J(Fp2)(point1) + J(Fp2)(point2)
    divisor = J(Fpx(divisor[_sage_const_0 ]), Fpx(divisor[_sage_const_1 ])) #return from Fp2 to Fp

d2 = divisor * _sage_const_0x10001 
assert d2[_sage_const_0 ].degree() == _sage_const_2 
x1 = d2[_sage_const_0 ][_sage_const_1 ]/_sage_const_2 
x2 = sqrt((x1*x1-d2[_sage_const_0 ][_sage_const_0 ])/_sage_const_43 )

encrypted = x1.lift() + (x2.lift() - _sage_const_1 ) * p
encrypted = int(encrypted).to_bytes(_sage_const_14 ,byteorder='little')

# end of the math
decrypted = decrypt(encrypted, key)
print(decrypted.hex())
# 0000000000000001000000000000 for the first confirmationId
# 0000000000000002000000000000 for the second confirmationId
# 0000000000000006000000000000 for the last confirmationId
assert decrypted[_sage_const_8 :] == b'\0' * _sage_const_6 
assert decrypted[_sage_const_7 ] <= _sage_const_0x80 
# all zeroes in decrypted[0:7] are okay for the checker
# more precisely: if decrypted[6] == 0, first 6 bytes can be anything
# otherwise, decrypted[0] = length, and decrypted[1:1+length] must match first length bytes of sha1(product key)

